import { Flashcard } from './flashcards';

export const FLASHCARDS_2: Flashcard[] = [
    {
        id: 1,
        question: "Objects and classes – what they are and how they are used",
        answer: "In Object-Oriented Programming (OOP) with Kotlin, a **Class** functions as a comprehensive blueprint or template that defines the structure and behavior of entities. It encapsulates data in the form of properties (variables) and behavior in the form of member functions (methods). A class definition helps in creating user-defined data types. \n\nAn **Object**, on the other hand, is a concrete runtime instance of a class. When a class is instantiated (e.g., `val car = Car()`), memory is allocated, and an object is created with its own specific state (values for properties). \n\nKotlin also introduces the `object` keyword specifically for the **Singleton pattern**, creating a class and a single instance of it effectively in one step. This is used for stateless utilities, constants, or shared resources. \n\n**Usage:** Classes are used to model real-world entities (like `User`, `Product`) or architectural components (like `ViewModel`, `Repository`). Objects are manipulated to perform operations, pass data, and manage application state."
    },
    {
        id: 2,
        question: "Class types – differences between a class, an abstract class, and an interface",
        answer: "**1. Standard Class:** A fully concrete class that can be instantiated directly. It can contain properties with backing fields and fully implemented methods. By default, classes in Kotlin are `final` and cannot be inherited from unless marked `open`. \n\n**2. Abstract Class:** Declared with the `abstract` keyword, this class cannot be instantiated directly. It serves as a base for subclasses and can contain a mix of fully implemented members and abstract members (which have no body and must be overridden). Crucially, abstract classes can hold state (properties with backing fields), unlike traditional interfaces. \n\n**3. Interface:** Defines a contract of behavior. Classes 'implement' interfaces. While Kotlin interfaces can contain default implementations for functions and abstract properties, they **cannot hold state** (they cannot have properties with backing fields). A class can inherit from only one class (abstract or standard) but can implement multiple interfaces, allowing for a form of multiple inheritance of behavior."
    },
    {
        id: 3,
        question: "Inheritance – what it is and how it works",
        answer: "**Inheritance** is a fundamental OOP pillar allowing a new class (subclass/child) to acquire the properties and methods of an existing class (superclass/parent). This promotes code reusability and establishes an 'is-a' relationship (e.g., a `Dog` is an `Animal`). \n\n**How it works in Kotlin:** \n- **Open by Default:** Unlike Java, all classes in Kotlin are `final` by default. To make a class inheritable, it must be marked with the `open` keyword (or be `abstract`). \n- **Syntax:** Inheritance is denoted by a colon `:`. E.g., `class Car : Vehicle()`. \n- **Constructors:** If the parent has a primary constructor, the child must initialize it immediately. \n- **Overriding:** Methods and properties intended to be redefined in the subclass must be marked `open` in the parent and `override` in the child. \n- **Super keyword:** The `super` keyword allows the subclass to call the parent's implementation of a method or property accessor. \n- **Single Inheritance:** Kotlin supports single class inheritance (a class has only one parent) but multiple interface implementation."
    },
    {
        id: 4,
        question: "Data classes vs. enum classes – when and why to use each",
        answer: "**Data Classes (`data class`):** \n- **Purpose:** Designed specifically to hold data/state. \n- **Features:** The compiler automatically generates utility methods based on properties declared in the primary constructor: `equals()`, `hashCode()`, `toString()`, `copy()`, and `componentN()` functions (for destructuring). \n- **When to use:** Use when you need a container for data (e.g., specific API response, a User profile model, a UI state object) where the identity of the object is defined by its data content rather than its memory address. \n\n**Enum Classes (`enum class`):** \n- **Purpose:** Represents a fixed, constant set of values (enumerations). \n- **Features:** Each instance is a singleton and distinct object. Enums can have properties and implement interfaces, but the set of instances is closed and known at compile time. \n- **When to use:** Use when a variable can only be one of a small set of predefined constants (e.g., `Direction.NORTH/SOUTH`, `Status.LOADING/SUCCESS/ERROR`, `UserType.ADMIN/GUEST`)."
    },
    {
        id: 5,
        question: "Asynchronous programming – differences between threads and coroutines",
        answer: "**Threads:** \n- **OS-Managed:** Threads are heavyweight processes managed directly by the Operating System. Creating and context-switching threads is expensive in terms of memory and CPU. \n- **Blocking:** Traditional thread operations often block the execution until a task is done, wasting resources. \n- **Concurrency:** One thread maps to one OS sequences of execution. \n\n**Coroutines:** \n- **User-Level:** Coroutines are lightweight 'virtual threads' managed by the Kotlin runtime, not the OS. You can run thousands of coroutines on a single thread. \n- **Suspending:** Coroutines support *suspension*. A function can pause its execution (suspend) without blocking the underlying thread, freeing that thread to do other work, and resume later. \n- **Structured Concurrency:** Kotlin Coroutines provide a hierarchy (scopes) that automatically manages cancellation and error propagation, preventing memory leaks (e.g., if a ViewModel is cleared, its coroutines are cancelled automatically). \n- **Usage:** Coroutines are the recommended standard in modern Android for network calls, database operations, and other background tasks."
    },
    {
        id: 6,
        question: "Mobile application components – the concept of an Activity, its lifecycle, and its role in an app",
        answer: "**Activity Concept:** An Activity represents a single, focused screen with a user interface. It acts as the entry point for interacting with the user. In the Model-View-Controller (MVC) analogy, it often acts as the controller (or View in MVVM) tying the UI layout to the data. \n\n**Role:** It manages the window in which the app draws its UI. An app may consist of multiple activities meant to handle different phases of the program (e.g., `LoginActivity`, `MainActivity`, `SettingsActivity`). \n\n**Lifecycle:** The Activity is managed by the OS through a series of callback methods: \n1. `onCreate()`: The activity is being created. Initialize UI and variables here. \n2. `onStart()`: The activity is becoming visible to the user. \n3. `onResume()`: The activity is in the foreground and interacting with the user. \n4. `onPause()`: The activity is partially obscured or the user is leaving (save unsaved data here). \n5. `onStop()`: The activity is no longer visible (release heavy resources). \n6. `onDestroy()`: The activity is finishing or being destroyed by the system (final cleanup). \n7. `onRestart()`: Called after onStop when the activity is being started again."
    },
    {
        id: 7,
        question: "Layouts in mobile applications – basic layout types and their characteristics",
        answer: "**Layouts** define the visual structure for a user interface, such as the UI for an Activity or Widget. \n\n**1. LinearLayout:** Arranges its children in a single direction, either vertically or horizontally. Supports 'weight' to distribute remaining space among children proportionally. Simple but can lead to deep nesting (performance hit). \n\n**2. ConstraintLayout:** The modern standard. highly flexible layout that allows you to position and size widgets in a way that’s flexible for various screen sizes. It uses constraints (connections) to other views or parent edges. It creates a flat view hierarchy, optimizing performance. \n\n**3. FrameLayout:** The simplest layout. Designed to block out an area on the screen to display a single item. Multiple children are stacked on top of each other (z-index), useful for overlays or fragment containers. \n\n**4. RelativeLayout:** (Legacy) Arranges children relative to each other (e.g., 'below view A', 'align parent right'). largely replaced by ConstraintLayout. \n\n**5. GridLayout:** Arranges views in a rectangular grid of rows and columns."
    },
    {
        id: 8,
        question: "Jetpack Compose – how it differs from the traditional XML-based UI approach",
        answer: "**Paradigm Shift:** \n- **XML (Imperative):** You define the layout in a static XML file (the 'what') and then manipulate it in Kotlin/Java code (the 'how') using `findViewById` or ViewBinding to set properties explicitly (e.g., `textView.text = \"Hello\"`). The UI state is held inside the View objects themselves. \n- **Jetpack Compose (Declarative):** You describe the UI entirely in Kotlin code as functions of the current state. When the state changes, the function re-executes ('recomposition') to update the UI. The UI is immutable and stateless; it is simply a reflection of the data. \n\n**Key Differences:** \n- **Language:** XML vs 100% Kotlin. \n- **Coupling:** XML requires context switching between resources and code. Compose keeps logic and UI together, increasing cohesion. \n- **Customization:** Creating custom views in XML is complex (subclassing View, custom attrs). In Compose, it's just another function. \n- **Dependencies:** Compose is unbundled from the OS (part of libraries), meaning updates don't require an Android OS update, whereas standard Views are tied to the SDK version."
    },
    {
        id: 9,
        question: "RecyclerView vs. ScrollView – how RecyclerView works and how it differs from ScrollView",
        answer: "**ScrollView:** \n- **Mechanism:** A simple container that allows its content to be scrolled. \n- **Rendering:** It creates and renders **ALL** child views immediately when the layout is inflated, regardless of whether they are visible on screen. \n- **Usage:** Ideal for static, limited content (e.g., a settings screen or a long article). \n- **Performance:** For long lists, it consumes massive memory and CPU, leading to UI lag (jank). \n\n**RecyclerView:** \n- **Mechanism:** Designed for large or dynamic datasets. \n- **Recycling:** It renders only the views currently visible on the screen (plus a small buffer). As the user scrolls, views that go off-screen are not destroyed; they are 'recycled' (cached) and rebound with new data for the incoming items. \n- **Components:** Requires an `Adapter` (binds data to views), a `ViewHolder` (caches view references to avoid lookups), and a `LayoutManager` (positions items). \n- **Performance:** Highly memory efficient and performant for lists with thousands of items."
    },
    {
        id: 10,
        question: "APIs and API keys – what they are and why they are required",
        answer: "**API (Application Programming Interface):** A set of rules and protocols that allows different software applications to communicate with each other. In mobile apps, this usually refers to RESTful web services (HTTP endpoints) that the app calls to fetch data (e.g., weather, user profiles) or trigger actions (e.g., process payment). \n\n**API Keys:** \n- **Definition:** A unique alphanumeric string used to identify the calling client (the app) to the API server. \n- **Why Required:** \n  1. **Authentication & Authorization:** Verifies that the client has permission to access the API. \n  2. **Rate Limiting:** Prevents abuse by limiting the number of requests a single client can make per minute/day. \n  3. **Analytics & Billing:** Tracks usage to charge the developer (e.g., Google Maps API charges per 1000 loads) or provide usage statistics. \n  4. **Security:** Helps administrators revoke access to compromised clients without shutting down the whole service."
    },
    {
        id: 11,
        question: "Purpose of Google Maps in mobile applications",
        answer: "Integrating Google Maps serves multiple critical functions in modern mobile apps: \n\n1. **Location Context:** Visualizing the user's current location relative to surroundings. \n2. **Point of Interest (POI) Discovery:** Displaying nearby businesses, ATMs, restaurants, or custom entity markers. \n3. **Navigation & Routing:** Providing turn-by-turn directions, estimating travel times, and visualizing routes between points. \n4. **Geofencing:** Triggering actions when a user enters/exits a specific geographic area (e.g., notification when near a store). \n5. **Data Visualization:** Displaying heatmaps or clustered data points geographically. \n6. **User Engagement:** Allowing users to pick locations (e.g., for delivery addresses or ride-hailing pickups) directly on an interactive interface."
    },
    {
        id: 12,
        question: "Using map APIs inside an Android application",
        answer: "Implementing Google Maps (via Maps SDK for Android) involves several technical steps: \n\n1. **Setup:** Create a project in Google Cloud Console, enable the 'Maps SDK for Android', and generate an API Key. \n2. **Configuration:** Add the API key to the `AndroidManifest.xml` meta-data. Include the Google Play Services dependencies in `build.gradle`. \n3. **UI Integration:** Add a `<fragment>` (class `SupportMapFragment`) or `MapView` to the XML layout. \n4. **Initialization:** In the Activity/Fragment, implementing `OnMapReadyCallback` and calling `getMapAsync(this)`. \n5. **Interacting with `GoogleMap`:** Once `onMapReady(googleMap)` is called, this object allows: \n   - **Markers:** `googleMap.addMarker()` to pin locations. \n   - **Camera:** `googleMap.moveCamera()` to zoom/pan to specific coordinates (`LatLng`). \n   - **Listeners:** Handling user clicks on the map or markers. \n   - **UI Settings:** Enabling/disabling zoom gestures, compass, my-location button."
    },
    {
        id: 13,
        question: "Kotlin vs. Java – key differences between these languages",
        answer: "**1. Null Safety:** Kotlin distinguishes nullable types (`String?`) from non-nullable types (`String`) at the compiler level, virtually eliminating `NullPointerException`. Java makes all objects nullable by default. \n**2. Conciseness:** Kotlin drastically reduces boilerplate. Features like Data Classes, Type Inference (`val`/`var`), and properties (automatic getters/setters) make code shorter and more readable. \n**3. Coroutines:** Kotlin has native support for Coroutines for async programming, whereas Java typically relies on Threads or reactive libraries (RxJava). \n**4. Extension Functions:** Kotlin allows adding methods to existing classes (even final ones from third-party libraries) without inheritance, using extensions. \n**5. Checks:** Kotlin removes Checked Exceptions (developers aren't forced to catch exceptions). \n**6. Functional Programming:** Kotlin has first-class support for higher-order functions and lambdas, making collection processing (map, filter) much smoother than Java 8+ Streams."
    },
    {
        id: 14,
        question: "Notifications – their purpose, how they are created, and how they work in mobile applications",
        answer: "**Purpose:** To inform the user of events, reminders, or updates from the app when the app is not currently in the foreground (or to provide persistent controls, like music players). \n\n**Creation & Architecture:** \n1. **Notification Channel (Android 8.0+):** You MUST create a channel (category) for notifications (e.g., 'Messages', 'Promotions'). This allows users to control settings per channel. \n2. **Builder:** Use `NotificationCompat.Builder` to construct the UI: set Title, Text, Icon, Priority, and PendingIntent (action to take when clicked). \n3. **Manager:** Use `NotificationManagerCompat.notify(id, notification)` to issue it. \n\n**How they work:** \n- The app sends the constructed notification object to the **System Notification Service**. \n- The OS decides how/when to display it (Status bar icon, Heads-up popup, Lock screen) based on priority and user settings. \n- It remains in the Notification Drawer until dismissed or interacted with."
    },
    {
        id: 15,
        question: "Push notifications – their purpose, how they are created, how they work, and how they differ from local notifications",
        answer: "**Local vs Push:** \n- **Local Notifications** are scheduled and triggered typically by the app itself running on the device (e.g., an alarm clock or calendar reminder logic). They don't require internet. \n- **Push Notifications** are triggered by a **Remote Server**. They allow the backend to reach the user even if the app is killed or the device is asleep. \n\n**How Push Works (e.g., via FCM - Firebase Cloud Messaging):** \n1. **Registration:** The app registers with FCM on launch and receives a unique device `token`. \n2. **Server:** The backend server sends this token to the app's database. \n3. **Sending:** The backend sends a message payload to the FCM server targeting that specific token. \n4. **Delivery:** Google's FCM connection (maintained by Play Services) wakes up the device and delivers the payload to the app. \n5. **Handling:** A `FirebaseMessagingService` in the app intercepts the message. If in background, the system tray often handles it automatically; if in foreground, the service callback fires. \n\n**Purpose:** Crucial for real-time engagement: chat messages, breaking news, delivery updates, social interactions."
    }
];
